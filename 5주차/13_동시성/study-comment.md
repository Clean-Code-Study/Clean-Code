# 13장 동시성

  ### 동시성(Concurrency)

  - 논리적인 용어
  - 동시에 실행되는 것처럼 보이는 것
  - 멀티태스킹을 위해 여러 개의 스레드가 번갈아가면서 실행되는 성질
  - 동시성을 이용한 싱글 코어의 멀티태스킹은 각 스레드들이 병렬적으로 실행되는 것처럼 보이지만, 사실은 번갈아가면서 조금씩 실행되고 있는 것

  ### 병렬성(Parallelism)

  - 물리적인 용어
  - 실제로 작업이 동시에 처리되는 것
  - 한개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질

    ---

  - 일단, 스레드란 프로세스가 할당받은 자원을 이용하는 실행의 단위를 말한다.
  - 운영체제는 프로세스마다 각각 독립된 메모리를 할당해주기 때문에 서로 공유되지 않는다. 하지만, 스레드는 각각 stack 영역은 따로 할당 받고 나머지 영역은 공유한다.
  - 프로세스의 경우 프로세스가 오류가 발생해 종료된다면 특별한 경우가 아니라면 다른 프로세스에는 영향을 주지 않는다. 하지만, 스레드의 경우 하나의 스레드에서 오류가 발생한다면 프로세스의 다른 스레드도 모두 강제 종료된다.

  ### Single Thread Model

  Single Thread Model은 프로세스 내에서 하나의 스레드 만으로 작업을 처리하는 것을 말합니다. 따라서 작업을 차례대로 처리할 수 밖에 없습니다.

  장점으로는 문맥 교환 작업을 하지 않는다는 점이 있습니다. 문맥 교환이란 CPU가 하나의 일을 실행하고 있는 상태에서 다른 일로 실행이 전환될 때, 기존의 상태 및 값들에 대한 정보를 저장하고 새로운 일의 정보로 교체하는 작업을 말합니다. 문맥교환은 많은 비용을 필요로 합니다.

  또 다른 장점으로는 자원 접근에 대한 동기화를 신경쓰지 않아도 된다는 점입니다. 여러개의 스레드를 사용할 경우, 모든 스레드가 일정 자원에 동시에 접근하거나, 똑같은 작업을 실행하려 한다면 에러가 발생하거나 원하는 값이 나오지 않을 수 있습니다. 이 점을 방지하고자 스레드들이 동시에 같은 자원에 접근하지 못하도록 제어를 해줘야합니다. Single Thread의 경우는 해당 과정을 신경쓰지 않아도 된다는 장점이 있습니다.

  단점으로는 연산량이 많은 작업을 하는 경우, 그 작업이 완료되어야 다른 작업을 수행할 수 있다는 점입니다. 또, 비슷한 맥락으로 에러 처리를 못 하는 경우 멈추게 되는 단점도 존재합니다. 반면, Multi Threads의 경우엔 에러 발생 시 새로운 스레드를 생성하여 극복하게 됩니다.

  ### Multi Threads Model

  Multi Threads Model은 둘 이상의 스레드를 동시에 실행시키는 기술을 말합니다. 이런 작업은 문맥교환(Context Switching)을 통해서 이루어집니다. 하나의 스레드에서 다음 스레드로 이동하면서, context switching이 일어나고 부분적으로 각각의 스레드에 대한 작업을 끝내는 것입니다. 즉, 사실은 동시에 일어나는 것이 아닌 context switching이 엄청 빠르게 일어나면서 동시에 수행되는 것처럼 보이는 것입니다.

  장점으로는 일부가 차단되거나 장시간 작업 수행시에도 다른 스레드들이 작업하고 있기 때문에 계속해서 실행이 가능하다는 점이 있습니다.

  또, 프로세스와 비교를 해보면 프로세스끼리는 공유 메모리와 메시지 전달로 통신을 하는데, 스레드는 자동으로 본인이 속해있는 프로세스의 자원과 상태를 공유하기 때문에 효율적인 운영이 가능합니다. 이렇게 자신이 속한 프로세스의 자원을 공유하기 때문에 스레드를 생성하고 context switch를 진행할 때 더 경제적입니다.

  단점으로는 설계의 복잡성이 있습니다. 멀티 스레드를 구현하기 위해서는 스레드 간의 동기화와 상호배제를 관리해야하는 복잡성이 존재합니다. 이에 따라 비용 또한 증가할 것입니다. 또, 공유 자원에 대한 동시 접근으로 인해 예측 불가능한 결과를 초래할 수 있다는 점이 있습니다.

  ### Green Threads (Goroutine, etc.) Model

  Green Threads Model은 VM(Virtual Machine)이나 Library 등에서 관리되는 스레드를 말하며, user-level 쓰레드라고도 불립니다. OS스레드 1개당 그린 스레드 여러 개를 할당시킵니다. 기존 스레드는 프로그램 스레드 1개당 OS스레드를 1:!로 매칭시키기 때문에 스레드 생성할 때 마다 시간이 들고, 용량도 커서 부담이 있습니다. 반면, 그린 스레드는 실제 스레드 생성을 하지 않아 시간이나 용량에 대한 부담이 적어졌습니다.

  golang은 일반적인 스레드가 아니라 경량스레드와 비슷한 역할을 하는 goroutine을 사용합니다. golang 엔진에서 일반적인 스레드와 조금 다른 방식으로 돌아갑니다. 고루틴의 경우 사용할 숫자를 지정하여 커널레벨 스레드와 연결할 수 있습니다. 커널레벨 스레드가 작아도 많은 수의 고루틴을 처리할 수 있습니다.


객체는 처리의 추상화다. 스레드는 일정의 추상화다. -James O.Coplien

동시성과 깔끔한 코드는 양립하기 어렵다. 여러 스레드를 동시에 돌리는 이유와 어려움, 깨끗한 코드를 작성하는 방법, 동시성을 테스트하는 방법과 문제점을 알아본다.

### 동시성이 필요한 이유?

동시성은 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다. 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 나아진다. 구조적 개선뿐만 아니라 응답 시간과 작업 처리량 개선을 위해 사용한다.

**미신과 오해**

- 동시성은 항상 성능을 높여준다.
  - 동시성은 “때로” 성능을 높여준다. 대기 시간이 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분한 경우에만 성능이 높아진다.
- 동시성을 구현해도 설계는 변하지 않는다.
  - 단일 스레드와 다중 스레드의 시스템은 설계가 판이하기 다르다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
  - 실제로 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야 한다.

**타당한 생각**

- 동시성은 다소 부하를 유발한다.
- 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

### 동시성 방어 원칙

**단일 책임 원칙(Single Responsibility Principle)**

주어진 메서드, 클래스, 컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다. 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다. 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다.

- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
- 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르면 훨씬 어렵다.

**자료 범위를 제한하라**

객체 하나를 공유하면 두 스레드가 서로 간섭하며 예상치 못한 결과를 내놓는다. 이런 문제를 해결하는 방안으로 공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 캡슐화하여 보호해야 한다.

- 자료 사본을 사용하라.
  - 공유 자료를 사용하지 않고, 객체를 복사해 읽기 전용으로 사용하거나 사용 후 결과를 가져오지 않는 방법도 가능하다.
- 스레드는 가능한 독립적으로 구현하라.
  - 다른 스레드와 자료를 공유하지 않는다. 각 스레드는 클라이언트 요청 하나를 처리한다.

### 실행 모델을 이해하라

기본 용어

- 한정된 자원(Bound Resource) : 다중 스레드 환경에서 사용하는 자원으로 크기나 숫자가 제한적이다.
- 상호 배제(Mutual Exclusion) : 한 번에 한 스레드만 공유 자료나 자원을 사용할 수 있는 경우
- 기아(Starvation) : 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다리는 경우
- 데드락(Deadlock) : 여러 스레드가 서로가 끝나기를 기다리는 경우. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.
- 라이브락(Livelock) : 락을 거는 단계에서 각 스레드가 서로를 방해하는 경우. 스레드는 계속해서 진행하려 하지만, 공명으로 인해 오랫동안 혹은 영원히 진행하지 못한다.

**생산자-소비자**

하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다. 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.

두 스레드가 사용하는 대기열은 한정된 자원이다. 생산자 스레드는 대기열에 빈 공간이 있어야 정보를 채운다. 즉, 빈 공간이 생길 때까지 기다린다. 소비자 스레드는 대기열에 정보가 있어야 가져온다. 즉, 정보가 채워질 때까지 기다린다.

따라서 잘못하면 두 스레드 모두 진행 가능함에도 불구하고 동시에 서로에게 시그널을 기다릴 가능성이 존재한다.

**읽기-쓰기**

읽기 스레드는 주된 정보원으로 공유 자원을 사용하지만, 쓰기 스레드가 공유 자원을 가끔 갱신한다고 하자.

이런 경우 처리율이 문제의 핵심인데, 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓일 수 있다. 대개는 쓰기 스레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어진다.

따라서 읽기 스레드의 요구와 쓰기 스레드의 요구를 적절히 만족시켜 처리율도 적당히 높이고 기아도 방지해야 한다.

**식사하는 철학자들**

둥근 식탁에서 식사하는 철학자들로 비유해본다.

![img1.daumcdn.png](4%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20e9d9c2b248b048a3a05b009c9b1f63aa/img1.daumcdn.png)

둥근 시각에 철학자 한 무리가 둘러앉아있고, 각 철학자 왼쪽에는 포크가 놓였다. 식탁 가운데는 커다란 스파게티 한 접시가 놓였다. 철학자들은 배가 고프지 않으면 생각하며 시간을 보낸다. 배가 고프면 양손에 포크를 집어들고 스파게티를 먹는다. 양손에 포크를 쥐지 않으면 먹지 못한다. 왼쪽 철학자나 오른쪽까지 기다려야 한다. 스파게티를 먹고 나면 포크를 내려놓고 배가 고플 때까지 다시 생각에 잠긴다.

여기서 철학자를 스레드로, 포크를 자원으로 바꿔 생각하면 된다.

주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪을 수 있다.

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

동기화는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다. 공유 객체 하나에는 메서드 하나만 사용해야 한다.

### 동기화하는 부분을 작게 만들어라.

자바에서 synchronized 키워드를 사용하면, 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다. 락은 스레드를 지연시키고 부하를 가중시키므로 임계 영역 수를 최대한 줄여야 한다.

그러나 수를 줄인다고 필요 이상으로 임계 영역 크기를 키우면 스레드 간에 경쟁이 늘어나고 프로그램 성능이 떨어진다.

### 올바른 종료 코드는 구현하기 어렵다.

깔끔하게 종료되는 코드는 올바르게 구현하기 어렵다.

가장 흔히 발생하는 문제가 데드락이다. 즉, 스레드가 절대 오지 않을 시그널을 기다린다. 예를 들어, 부모 스레드가 자식 스레드를 여러 개 만든 후 종료시키려는 데 만약 자식 스레드 중 하나가 데드락에 걸렸다면 부모 스레드는 영원히 기다려야 한다.

따라서, 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. 생각보다 오래걸리고 어려우므로 이미 나온 알고리즘을 검토하라.

### 스레드 코드 테스트하기

문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 테스트가 실패하면 원인을 추적하라. 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대로 안된다.

- 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라.
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자.
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라.
- 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라.
- 프로세서 수보다 많은 스레드를 돌려보라.
- 다른 플랫폼에서 돌려보라.
- 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라. 코드에 보조 코드를 추가하는 방법은 직접 구현해도 괜찮고 몇가지 자동화 기술을 사용해도 괜찮다.
